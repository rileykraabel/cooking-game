#ifndef BOX2DWIDGET_H
#define BOX2DWIDGET_H

#include <QApplication>
#include <QWidget>
#include <QTimer>
#include <QPainter>
#include <QMouseEvent>
#include <QGraphicsView>

#include <box2d/box2d.h>
#include <objectName.h>
#include <model.h>
#include <collisioncallback.h>

/*!
 * \brief The Box2DWidget class to simulate the game world.
 * \authors Ethan Collier, Haidan Nelson, Riley Kraabel, Victoria Locke, Samantha Roberts, Jack Larson for CS 3505 A9.
 */
class Box2DWidget : public QGraphicsView
{
public:
    /*!
     * \brief Box2DWidget: Constructor method for Box2D implementations.
     * \param parent: autogenerated QWidget object for interactions.
     * \param model: autogenerated Model object for interactions.
     */
    Box2DWidget(QWidget* parent = nullptr, Model* model = nullptr);

    /*!
     * \brief ~Box2DWidget: Destructor method for Box2D implementations.
     */
    ~Box2DWidget();

    /*!
     * \brief simulate: Simulate a game tick.
     */
    void simulate();

    /*!
     * \brief addBody: Add a body to the gameWorld.
     * \param object: The UserData to add (a gameobject with a name and a picture).
     * \return b2Body type - The body that was added to the world.
     */
    b2Body* addBody(GameObject* object, QPoint mousePosition = QPoint(0.0f, 0.0f));

    /*!
     * \brief removeObjects: Remove all objects from the vector.
     * \param bodies: vector object of b2Body type objects - The bodies to remove.
     */
    void removeObjects(std::vector<b2Body*> bodies);

    /*!
     * \brief render: Renders the game frame.
     */
    void render();

    /*!
     * \brief dragBody: Use linear impulses to drag the body to the current mouse position.
     * \param body: b2Body type object - The body to drag.
     */
    void dragBody(b2Body* body);

    /*!
     * \brief setupWorld: Setup the world, background, boundries, etc.
     */
    void setupWorld();

    /*!
     * \brief startSimulation: Use a QTimer to start the simulation.
     */
    void startSimulation();

    /*!
     * \brief updateScene: Update the scene with new objects if they were added as a result of a collision.
     */
    void updateScene();

    /*!
     * \brief resetWorld: Reset all dynamic objects. Static objects are not affected.
     */
    void resetWorld();

    /*!
     * \brief addBodies: Adds bodies from collisionCallback.
     */
    void addBodies();

    /*!
     * \brief mousePressEvent: Detect if a mouse press intersects a body.
     * \param event: QMouseEvent type object - Position of the mouse.
     */
    void mousePressEvent(QMouseEvent *event) override;

    /*!
     * \brief setModel: Sets the model of the application.
     * \param model: Model type object - The model to set.
     */
    void setModel(Model* model);

    /*!
     * \brief scaleFactor: Constant representing the scaleFactor of Qt pixels to Box2D meters.
     */
    static constexpr float32 scaleFactor = 20.0f;

private:
    /*!
     * \brief scene: The scene to draw on.
     */
    QGraphicsScene* scene;

    /*!
     * \brief world: The world where the physics simulation happens.
     */
    b2World* world;

    /*!
     * \brief grabbedBody: The body being dragged around by the mouse.
     */
    b2Body* grabbedBody;

    /*!
     * \brief mousePosition: The current mouse position as a QPoint object.
     */
    QPoint  mousePosition;

    /*!
     * \brief callback: Listens for collisions and does actions if certain collisions happen.
     *      Also stores an array of bodies to change or delete based on those collisions.
     */
    collisionCallback* callback;

    /*!
     * \brief background: The background image to use.
     */
    QPixmap background;

    /*!
     * \brief model: Stores the selected recipe.
     */
    Model* model;
};

#endif // BOX2DWIDGET_H
